---
layout: blog_post
title: Software Watchdog Thread for High Availability
published: false
date: '2010-04-11 22:30:32'
redirect_from:
- import_node/462
- node/4402
---

I worked on high availability massively multithreaded C++ code over the past several years. The goal was to create software that remained running for as many hours a day as possible. A technique that I used was to have a secondary process, such as cron, that checks to make sure the application is running. If the secondary process detects that the mission critical process is not running, it restarts it. This works for many cases, but does not address the problem of a deadlocked or unresponsive application. Even with the best techniques, it may be impossible to find and fix every single possible situation that can cause a thread to hang. This is particularly true if your application interacts with external applications or blocking data sources. One solution is to try and detect a deadlock scenario and force the application to crash so that it can be restarted by the monitoring application. This is a failsafe mechanism, to make sure the application stays up as much as possible. The solution in the embedded hardware world is the [watchdog](http://en.wikipedia.org/wiki/Watchdog_timer). In the traditional sense, a watchdog forces the hardware to reset if it has not been touched. There are both hardware and software implementations of watchdogs, and they work great if the host is only running one application. This does not quite meet our needs. We only need to make sure that one application is reset, not the entire platform. Our solution is to create a thread that runs periodically and checks to make sure a timer has been updated within a certain time frame. If the timer has not been updated, `abort()` is called to force the application to quit without attempting to call destructors. Calling destructors would only exacerbate the problem we are trying to resolve. The following code monitors any number of threads. Each time a thread calls "`touch()`," that thread's id is added to the set that is being monitored, and the new thread most continue to call touch. If any thread that has called touch at least once fails to call touch within a configured timeframe, the application will exit. The [complete source](http://bitbucket.org/lefticus/emptycrate_test/src/tip/cpp/watchdog_thread.cpp) of this code will be maintained in my [bitbucket account](http://bitbucket.org/lefticus/), as will all [significant code examples](http://bitbucket.org/lefticus/emptycrate_test/src/) from here out. ` #include <boost/thread.hpp> #include <map>  class Watchdog_Thread {   private:     typedef std::map ThreadTimestamps;     ThreadTimestamps m_timestamps;     int m_timeout;     boost::shared_mutex m_mutex;     boost::thread m_thread;      void watchdog()     {       try {         while (!boost::this_thread::interruption_requested())         {           //Every second check all of the timestamps and see if any are out of spec           boost::this_thread::sleep(boost::posix_time::seconds(1));            boost::shared_lock l;            ThreadTimestamps::const_iterator itr = m_timestamps.begin();           ThreadTimestamps::const_iterator end = m_timestamps.end();            boost::posix_time::ptime curtime = boost::posix_time::second_clock::universal_time();            while (itr != end)           {             if ( (curtime - itr->second).total_seconds() >= m_timeout )             {               // One of the monitored threads failed to be touched               // so exit the application.               // We call abort because a missd touch implies a serious problem               // such as a deadlock and we do not want to call destructors               abort();             }             ++itr;           }         }       } catch (const boost::thread_interrupted &) {         // Interrupted, leave normally       }     }    public:     // Create a new Watchdog_Thread object with a given timeout     Watchdog_Thread(int t_timeout)       : m_timeout(t_timeout), m_thread(&Watchdog_Thread::watchdog, this)     {     }      ~Watchdog_Thread()     {       //Tell the watchdog that it is time to shutdown       m_thread.interrupt();        //And join in the constructor       assert(m_thread.get_id() != boost::this_thread::get_id());       m_thread.join();     }      void touch()     {       // Update the timestamp for the thread id that is executing the touch       // Note that each new thread that calls touch() implicitly adds a new thread that is being       // monitored.       boost::unique_lock l(m_mutex);       m_timestamps[boost::this_thread::get_id()] = boost::posix_time::second_clock::universal_time();     } };  int main(int argc, const char* argv[]) {   if (argc < 2 || atoi(argv[1]) == 1)   {     std::cout << "Usage: \n";     std::cout << "  1 exit normally after 6 seconds\n";     std::cout << "  2 timeout and fail after 3 seconds\n";   }    std::cout << "Starting watchdog for 3 second timeout\n";   Watchdog_Thread wt(3);    switch(atoi(argv[1]))   {     case 1:       std::cout << "Touching the watchdog 6 times then exiting normally\n";       for (int i = 0; i < 6; ++i)       {         std::cout << "Touching watchdog\n";         wt.touch();         boost::this_thread::sleep(boost::posix_time::seconds(1));       }       break;      case 2:       std::cout << "Touching the watchdog once, then sleeping for 7 seconds. Should abort exit within 4\n";       std::cout << "Touching watchdog\n";       wt.touch();       boost::this_thread::sleep(boost::posix_time::seconds(7));       break;   }    std::cout << "Exiting normally\n"; }`
